{"version":3,"file":"main.js","mappings":"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","sources":["webpack://webpack-template/webpack/bootstrap","webpack://webpack-template/webpack/runtime/define property getters","webpack://webpack-template/webpack/runtime/hasOwnProperty shorthand","webpack://webpack-template/./src/modules/gameboard.js","webpack://webpack-template/./src/modules/players.js","webpack://webpack-template/./src/modules/dom.js","webpack://webpack-template/./src/modules/computerAI.js","webpack://webpack-template/./src/modules/ships.js","webpack://webpack-template/./src/modules/shipPlacement.js","webpack://webpack-template/./src/app.js","webpack://webpack-template/./src/modules/game.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class Gameboard {\n  constructor() {\n    this.board = [];\n    this.storeShip = new Map(); // Track each ship's coordinates within the board\n    this.missedHits = []; // Store all of the coordinates of missed hits\n    this.trackAttacks = new Set(); // Store only non-duplicate attacks\n    this.boardSize = 10;\n  }\n\n  // Create a 10x10 board\n  createBoard() {\n    for (let i = 0; i < this.boardSize; i++) {\n      this.board[i] = new Array(this.boardSize).fill(\"0\");\n    }\n  }\n\n  // Place ship on the board based on its coordinates\n  placeShip(ship, coordinates) {\n    if (ship.length !== coordinates.length) {\n      throw new Error(\n        \"Ship length does not match the number of provided coordinates\",\n      );\n    }\n\n    coordinates.forEach(([x, y]) => {\n      this.board[x][y] = \"■\"; // for visuals (ship)\n      this.storeShip.set(`${x},${y}`, ship); // Map the coordinate on the board to its corresponding ship\n    });\n  }\n\n  // Attack the ship and check if it was a hit or miss\n  receiveAttack(x, y) {\n    const ship = this.storeShip.get(`${x},${y}`);\n\n    this.trackAttacks.add(`${x},${y}`); // Avoid same coordinate attacks\n\n    // If attack coordinates match ship coordinates, then it was hit, else, miss\n    if (ship) {\n      ship.hit(x, y);\n      this.board[x][y] = \"hit\";\n    } else {\n      this.board[x][y] = \"miss\";\n      this.missedHits.push([x, y]);\n    }\n    return ship;\n  }\n\n  // Check if all ships have been sunk\n  allSunk() {\n    const uniqueShips = new Set(this.storeShip.values()); // Store each ship in the set\n\n    // Find if any ships have not been sunk yet\n    for (const ship of uniqueShips) {\n      if (!ship.isSunk()) return false;\n    }\n    return true;\n  }\n\n  // Reset the board\n  resetBoard() {\n    for (let i = 0; i < this.boardSize; i++) {\n      this.board[i].fill(\"0\");\n    }\n\n    this.storeShip.clear();\n    this.trackAttacks.clear();\n    this.missedHits = [];\n  }\n}\n","import { Gameboard } from \"./gameboard.js\";\nexport class Player {\n  constructor(isComputer = false) {\n    this.gameboard = new Gameboard();\n    this.isComputer = isComputer;\n  }\n}\n\nexport const realPlayer = new Player();\nexport const computerPlayer = new Player(true);\n\n// Initialize the boards for both players\nrealPlayer.gameboard.createBoard();\ncomputerPlayer.gameboard.createBoard();\n","import { computerPlayer, realPlayer } from \"./players.js\";\nimport { game } from \"../app.js\";\n\n// Player board elements\nexport const realPlayerBoardEl = document.querySelector(\"#real-player-board\");\nexport const computerPlayerBoardEl = document.querySelector(\"#computer-board\");\n\nconst sidePanel = document.querySelector(\".playerShips\");\nconst restartBtn = document.querySelector(\".restart-btn\");\n\nconst winnerMsg = document.querySelector(\".winner-msg\");\nconst realPlayerStatus = document.querySelector(\".real-player-status\");\nconst computerPlayerStatus = document.querySelector(\".computer-player-status\");\nconst realPlayerLabels = document.querySelectorAll(\n  \".row-labels.real-label, .col-labels.real-label\",\n);\nconst computerPlayerLabels = document.querySelectorAll(\n  \".row-labels.computer-label, .col-labels.computer-label\",\n);\nconst shipNames = [\n  \"Destroyer\",\n  \"Submarine\",\n  \"Cruiser\",\n  \"Battleship\",\n  \"Carrier\",\n];\n\n// Track ship rotation state\nlet shipRotationState = {};\n\n// Track the id of the ship that currently being dragged, and ship segment\n// since dragover event can't access dataTransfer.getData() due to browser security restrictions\nlet currentDraggedShipId = null;\nlet currentSegmentOffset = 0;\n\n// Render gameboard for both players\nexport function renderBoard(gameboard, boardElement) {\n  const boardSize = 10;\n  const board = gameboard.board;\n\n  boardElement.innerHTML = \"\"; // Clear the board before rerendering\n\n  for (let i = 0; i < boardSize; i++) {\n    const row = document.createElement(\"div\");\n    row.classList.add(\"row\");\n    boardElement.appendChild(row);\n\n    for (let j = 0; j < boardSize; j++) {\n      const cell = document.createElement(\"div\");\n      cell.classList.add(\"column\");\n\n      // Set coordinate of the cell\n      cell.setAttribute(\"data-row\", i);\n      cell.setAttribute(\"data-col\", j);\n\n      const value = board[i][j]; // Get value of the cell (\"ship\", \"hit\", or \"miss\")\n\n      updateCellState(value, cell);\n      row.appendChild(cell);\n    }\n  }\n}\n\n// Render side panel with ships\nexport function renderSidePanel() {\n  sidePanel.innerHTML = \"\";\n\n  const shipSizes = [2, 3, 3, 4, 5];\n\n  shipSizes.forEach((size, i) => {\n    const shipNum = i + 1;\n\n    const shipWrapper = document.createElement(\"div\");\n    shipWrapper.classList.add(\"shipWrapper\", `wrapper${shipNum}`);\n\n    // Ship attributes\n    const shipEl = document.createElement(\"div\");\n    shipEl.id = `ship${shipNum}`;\n    shipEl.setAttribute(\"draggable\", true);\n    shipEl.setAttribute(\"data-length\", size);\n    shipEl.setAttribute(\"data-orientation\", \"horizontal\");\n\n    const span = document.createElement(\"span\");\n    span.classList.add(\"shipName\");\n    span.textContent = shipNames[i];\n\n    // Each cell of the ship\n    for (let i = 0; i < size; i++) {\n      const segment = document.createElement(\"div\");\n      segment.classList.add(\"cell\");\n      segment.setAttribute(\"data-index\", i);\n      shipEl.appendChild(segment);\n    }\n\n    shipEl.appendChild(span);\n    shipWrapper.appendChild(shipEl);\n    sidePanel.appendChild(shipWrapper);\n  });\n\n  // Enable it after side panel has rendered\n  enableShipDragging();\n}\n\n// Update the cell's appearance based on game state\nexport function updateCellState(value, cell) {\n  switch (value) {\n    case \"■\":\n      cell.classList.add(\"ship\");\n      break;\n    case \"hit\":\n      cell.classList.add(\"hit\");\n      break;\n    case \"miss\":\n      cell.classList.add(\"miss\");\n      break;\n    case \"sunk\":\n      cell.classList.remove(\"hit\");\n      cell.classList.add(\"sunk\");\n      break;\n  }\n}\n\n// Switch boards based on player's turn\nexport function switchBoard(player, placing = false) {\n  const isComputer = player.isComputer;\n\n  // Disable random/rotate buttons by default\n  const randomBtn = document.querySelector(\".random-btn\");\n  const rotateBtn = document.querySelector(\".rotate-btn\");\n  const restartBtn = document.querySelector(\".restart-btn\");\n\n  rotateBtn.classList.add(\"disable\", \"dim\");\n  restartBtn.classList.add(\"disable\", \"dim\");\n\n  // Update board and label visibility\n  computerPlayerBoardEl.classList.toggle(\"disable\", isComputer);\n  computerPlayerBoardEl.classList.toggle(\"dim\", isComputer && !placing);\n  realPlayerBoardEl.classList.toggle(\"dim\", !isComputer || placing);\n\n  realPlayerLabels.forEach((label) =>\n    label.classList.toggle(\"dim\", !isComputer || placing),\n  );\n  computerPlayerLabels.forEach((label) =>\n    label.classList.toggle(\"dim\", isComputer && !placing),\n  );\n\n  // Reset status messages\n  computerPlayerStatus.textContent = \"\";\n  realPlayerStatus.textContent = \"\";\n\n  // Players placing their ships (update status)\n  if (placing) {\n    if (isComputer) {\n      computerPlayerStatus.textContent = \"Computer is placing their ships...\";\n      computerPlayerBoardEl.classList.remove(\"dim\");\n      computerPlayerLabels.forEach((label) => label.classList.remove(\"dim\"));\n      randomBtn.classList.add(\"disable\", \"dim\");\n    } else {\n      realPlayerStatus.textContent = \"Place your ships on the board!\";\n      computerPlayerBoardEl.classList.add(\"disable\", \"dim\");\n      realPlayerBoardEl.classList.remove(\"dim\");\n      randomBtn.classList.remove(\"disable\", \"dim\");\n      rotateBtn.classList.remove(\"disable\", \"dim\");\n    }\n  } else {\n    // Players placed their ships (now attacking)\n    if (isComputer) {\n      realPlayerStatus.textContent = \"Computer is attacking...\";\n    } else {\n      computerPlayerStatus.textContent = \"Attack the computer!\";\n    }\n    restartBtn.classList.remove(\"disable\", \"dim\");\n  }\n}\n\n// Display the winner\nexport function displayWinner(winner) {\n  const isComputer = winner.isComputer;\n\n  computerPlayerBoardEl.classList.add(\"disable\");\n\n  const winnerBoard = isComputer ? computerPlayerBoardEl : realPlayerBoardEl;\n  const loserBoard = isComputer ? realPlayerBoardEl : computerPlayerBoardEl;\n\n  // Row-col labels\n  const winnerLabels = isComputer ? computerPlayerLabels : realPlayerLabels;\n\n  // Winner message\n  winnerMsg.style.display = \"block\";\n  winnerMsg.textContent = isComputer ? \"Computer wins!\" : \"You win!\";\n\n  realPlayerStatus.textContent = \"\";\n  computerPlayerStatus.textContent = \"\";\n\n  winnerBoard.classList.remove(\"dim\");\n  loserBoard.classList.add(\"dim\");\n\n  winnerLabels.forEach((label) => label.classList.remove(\"dim\"));\n\n  winnerBoard.classList.add(isComputer ? \"computer-shadow\" : \"player-shadow\");\n\n  restartBtn.classList.add(\"restart-btn-shadow\");\n}\n\n// Get coordinates from the clicked cell\nexport function getCoordinates(cell) {\n  const x = Number(cell.getAttribute(\"data-row\"));\n  const y = Number(cell.getAttribute(\"data-col\"));\n\n  return [x, y];\n}\n\n// HANDLE DRAG AND DROP API\nexport function setupPlayerShipDrop(callback, isValidPlacement) {\n  // Listen for player dropping a ship on the gameboard\n  // Then calculate coordinates of the ship that was dropped\n  realPlayerBoardEl.addEventListener(\"drop\", (e) => {\n    e.preventDefault();\n\n    const { row, col, shipEl, offset, shipLength } = getShipData(e);\n    const coordinates = computeShipPlacement(row, col, shipEl, offset);\n\n    // Pass coordinates and length of each ship through callback for future use\n    callback(coordinates, shipLength, shipEl);\n\n    // Rerender the gameboard to update player's ship placements\n    renderBoard(realPlayer.gameboard, realPlayerBoardEl);\n    document.querySelector(\".restart-btn\").classList.remove(\"disable\", \"dim\");\n  });\n\n  // Allow drops on the gameboard\n  realPlayerBoardEl.addEventListener(\"dragover\", (e) => {\n    e.preventDefault();\n\n    // Reset highlighting and disable rotate button\n    document.querySelectorAll(\".highlightShip\").forEach((el) => {\n      el.classList.remove(\"highlightShip\");\n    });\n\n    hoverShipPlacementEffect(e, isValidPlacement);\n  });\n\n  // Remove hovers when drag leaves the board\n  realPlayerBoardEl.addEventListener(\"dragleave\", () => {\n    document.querySelectorAll(\".hovered\").forEach((cell) => {\n      cell.classList.remove(\"hovered\", \"invalid\");\n    });\n  });\n}\n\nfunction enableShipDragging() {\n  // Get index of the ship's segment that the user clicked and is about to drag\n  document.querySelectorAll(\"[id^='ship']\").forEach((shipEl) => {\n    let trackShipsSegment = 0;\n\n    shipEl.addEventListener(\"mousedown\", (e) => {\n      const segment = e.target.closest(\".cell\");\n      if (segment) {\n        trackShipsSegment = Number(segment.getAttribute(\"data-index\"));\n      }\n    });\n\n    // Set drag data, to identify the dragged ship and the ship's segment offset\n    shipEl.addEventListener(\"dragstart\", (e) => {\n      // ! Use these when dragover event is not able to access this data through e.dataTransfer.getData()\n      currentDraggedShipId = shipEl.id;\n      currentSegmentOffset = trackShipsSegment;\n\n      // Store it in dataTransfer if no fallback is required\n      e.dataTransfer.setData(\"offset\", trackShipsSegment.toString());\n      e.dataTransfer.setData(\"shipID\", shipEl.id);\n    });\n  });\n}\n\n// Remove ship from side panel after drag and drop\nexport function shipRemoval(ship) {\n  ship.style.maxWidth = \"0\";\n  ship.style.opacity = \"0\";\n\n  setTimeout(() => ship.remove(), 300);\n}\n\n// Get data from the ship that was dropped\nfunction getShipData(e) {\n  const cell = e.target;\n\n  // Coordinates of the cell on the board where ship was dropped\n  const row = Number(cell.getAttribute(\"data-row\"));\n  const col = Number(cell.getAttribute(\"data-col\"));\n\n  // Get the string of the ship that was dragged\n  const shipId = e.dataTransfer.getData(\"shipID\");\n\n  // Fallback to global variable if shipEl from dataTransfer is null\n  const shipEl =\n    document.getElementById(shipId) ??\n    document.getElementById(currentDraggedShipId);\n\n  const shipLength = Number(shipEl.getAttribute(\"data-length\"));\n\n  // Use dataTransfer offset if possible, fallback to global one\n  const offsetData = e.dataTransfer.getData(\"offset\");\n  const offset = offsetData !== \"\" ? Number(offsetData) : currentSegmentOffset;\n\n  return { row, col, shipEl, offset, shipLength };\n}\n\n// Calculate coordinates with offset for precised alignment on the board\nfunction computeShipPlacement(row, col, shipEl, offset) {\n  const orientation = shipEl.getAttribute(\"data-orientation\");\n  const shipSize = Number(shipEl.getAttribute(\"data-length\"));\n  const isHorizontal = orientation === \"horizontal\";\n\n  // Offset correction to align grabbed ship segment with the drop cell\n  // ... to ensure ship starts at precise board coordinates\n  const x = isHorizontal ? row : row - offset;\n  const y = isHorizontal ? col - offset : col;\n\n  // Get ship coordinates from corrected starting position\n  return game.playerShipPlacer.getShipCoordinates(x, y, shipSize, isHorizontal);\n}\n\n// Visually show hover effect for potential ship placement on the gameboard\nfunction hoverShipPlacementEffect(e, isValidPlacement) {\n  const { row, col, shipEl, offset } = getShipData(e);\n  const coordinates = computeShipPlacement(row, col, shipEl, offset);\n  const isValid = isValidPlacement(coordinates);\n\n  // Remove previous hover and invalid styling\n  document.querySelectorAll(\".hovered\").forEach((cell) => {\n    cell.classList.remove(\"hovered\", \"invalid\");\n  });\n\n  coordinates.forEach(([x, y]) => {\n    // Get the cell at current ship coordinate\n    const cell = realPlayerBoardEl.querySelector(\n      `[data-row=\"${x}\"][data-col=\"${y}\"]`,\n    );\n\n    if (cell) {\n      cell.classList.add(\"hovered\");\n      // If placement of ship is invalid during hover, apply it visually\n      if (!isValid) cell.classList.add(\"invalid\");\n    }\n  });\n\n  e.dataTransfer.dropEffect = isValid ? \"move\" : \"none\";\n}\n\n// Visually select the ship to drag\nfunction highlightShipSelection() {\n  document.querySelectorAll(\"[id^='ship']\").forEach((shipEl) => {\n    shipEl.addEventListener(\"mousedown\", (e) => {\n      const ship = e.target.closest(\"[id^='ship']\");\n\n      // Remove each highlighter before processing the new one\n      document.querySelectorAll(\".highlightShip\").forEach((el) => {\n        el.classList.remove(\"highlightShip\");\n      });\n\n      ship.classList.add(\"highlightShip\");\n    });\n  });\n}\n\n// HANDLE SHIP ROTATION\nfunction handleShipRotation() {\n  const selectedShip = document.querySelector(\"[id^='ship'].highlightShip\");\n  const shipName = document.querySelector(\n    \"[id^='ship'].highlightShip .shipName\",\n  );\n\n  if (!selectedShip) return;\n\n  const selectedShipID = selectedShip.id;\n\n  const wasRotated = shipRotationState[selectedShipID] ?? false; // If state is undefined/null default it to false (horizontal)\n  const isRotated = !wasRotated; // Toggle current rotation state\n\n  shipRotationState[selectedShipID] = isRotated; // Store current rotation state of the ship\n\n  if (isRotated) {\n    selectedShip.setAttribute(\"data-orientation\", \"vertical\");\n    selectedShip.classList.add(\"rotated\");\n    shipName.style.transform = \"rotate(-90deg)\";\n  } else {\n    selectedShip.setAttribute(\"data-orientation\", \"horizontal\");\n    selectedShip.classList.remove(\"rotated\");\n    shipName.style.transform = \"rotate(0deg)\";\n  }\n}\n\nfunction setupShipRotation() {\n  const rotateBtn = document.querySelector(\".rotate-btn\");\n\n  // Remove old listeners via clone\n  const newRotateBtn = rotateBtn.cloneNode(true);\n  rotateBtn.parentNode.replaceChild(newRotateBtn, rotateBtn);\n\n  newRotateBtn.addEventListener(\"click\", handleShipRotation);\n}\n\n// HANDLE SHIP PLACEMENT RANDOMIZATION\nfunction handleRandomShipPlacement(ships, btn) {\n  if (game.playerShipPlacer.allPlaced()) return;\n  realPlayer.gameboard.resetBoard();\n\n  // Randomize placement\n  game.playerShipPlacer.placeComputerShips();\n\n  // Remove ships from the side panel\n  ships.forEach((ship) => shipRemoval(ship));\n\n  // Rerender player's gameboard after placement\n  renderBoard(realPlayer.gameboard, realPlayerBoardEl);\n\n  btn.style.cursor = \"default\";\n  document.querySelector(\".restart-btn\").classList.add(\"disable\", \"dim\");\n}\n\nfunction setupRandomShipPlacement() {\n  const ships = document.querySelectorAll(\".shipWrapper\");\n  const randomBtn = document.querySelector(\".random-btn\");\n\n  const newRandomBtn = randomBtn.cloneNode(true);\n  randomBtn.parentNode.replaceChild(newRandomBtn, randomBtn);\n\n  newRandomBtn.addEventListener(\"click\", () =>\n    handleRandomShipPlacement(ships, newRandomBtn),\n  );\n}\n\n// HANDLE RESTART\nfunction handleRestart() {\n  restartBtn.classList.remove(\"restart-btn-shadow\");\n  winnerMsg.style.display = \"none\";\n  realPlayerBoardEl.classList.remove(\"player-shadow\");\n  computerPlayerBoardEl.classList.remove(\"computer-shadow\");\n\n  game.reset();\n\n  shipRotationState = {};\n\n  // Rerender the boards after reset\n  renderBoard(realPlayer.gameboard, realPlayerBoardEl);\n  renderBoard(computerPlayer.gameboard, computerPlayerBoardEl);\n\n  renderSidePanel();\n\n  highlightShipSelection();\n  setupShipRotation();\n  setupRandomShipPlacement();\n\n  switchBoard(realPlayer, true); // Real player placing their ships\n  game.startSetup();\n\n  // Start with restart button being disabled\n  document.querySelector(\".restart-btn\").classList.add(\"disable\", \"dim\");\n}\n\nfunction setupPlayAgain() {\n  restartBtn.addEventListener(\"click\", handleRestart);\n}\n\nexport function setupUI() {\n  setupPlayAgain();\n\n  // Render the game boards for 2 players\n  renderBoard(realPlayer.gameboard, realPlayerBoardEl);\n  renderBoard(computerPlayer.gameboard, computerPlayerBoardEl);\n\n  renderSidePanel();\n\n  highlightShipSelection();\n\n  setupShipRotation();\n  setupRandomShipPlacement();\n}\n","// AI logic for when computer attacks\nexport class AIController {\n  constructor(gameboard) {\n    this.boardSize = gameboard.boardSize;\n    this.oppGameboard = gameboard;\n    this.lastHit = null; // Track last hit of the ship\n    this.nextTarget = null; // Track next target\n    this.currTargetShip = null; // Track the attacked ship\n  }\n\n  // Check if attack is within the boundaries and hasn't been attempted yet\n  isValidAttack(x, y) {\n    return (\n      x >= 0 &&\n      x < this.boardSize &&\n      y >= 0 &&\n      y < this.boardSize &&\n      !this.oppGameboard.trackAttacks.has(`${x},${y}`)\n    );\n  }\n\n  // Computer attacks based on the data it gathered\n  computerAttacks() {\n    let coordinate;\n\n    if (this.nextTarget) {\n      // If next target is known after 2+ hits, target directional cell\n      coordinate = this.nextTarget;\n      this.nextTarget = null;\n    } else if (this.lastHit) {\n      // Target adjacent cells after first hit was detected\n      coordinate = this.targetShip(this.lastHit);\n    } else {\n      // Hunt for the ships randomly if no hit was detected\n      coordinate = this.huntShip();\n    }\n\n    const [x, y] = coordinate;\n    const keyCoordinate = `${x},${y}`;\n    const ship = this.oppGameboard.storeShip.get(keyCoordinate);\n\n    this.oppGameboard.receiveAttack(x, y);\n    this.updateAttackState(ship, x, y);\n\n    return [x, y];\n  }\n\n  // Generate a random coordinate\n  getRanCoordinate(min, max) {\n    const x = Math.floor(Math.random() * (max - min + 1) + min);\n    const y = Math.floor(Math.random() * (max - min + 1) + min);\n\n    return [x, y];\n  }\n\n  // Randomly search for a ship to hit\n  huntShip() {\n    let coordinate;\n\n    while (true) {\n      coordinate = this.getRanCoordinate(0, this.boardSize - 1);\n\n      if (this.isValidAttack(coordinate[0], coordinate[1])) {\n        break;\n      }\n    }\n    return coordinate;\n  }\n\n  // Attack neighbor cells if last attack was a hit\n  targetShip(coordinate) {\n    const [x, y] = coordinate;\n\n    // Possible moves from the computer\n    const directions = [\n      [-1, 0], // up\n      [1, 0], // down\n      [0, -1], // left\n      [0, 1], // right\n    ];\n\n    // Mix up the direction to move\n    const mix = directions.sort(() => Math.random() - 0.5);\n\n    for (const [dx, dy] of mix) {\n      const sx = x + dx;\n      const sy = y + dy;\n\n      // Check if it's valid to attack\n      if (this.isValidAttack(sx, sy)) {\n        return [sx, sy];\n      }\n    }\n\n    // Fallback to a random attack if no adjacent cells can be targeted\n    return this.huntShip();\n  }\n\n  // Determine direction\n  getDirection([x1, y1], [x2, y2]) {\n    const dx = x2 - x1; // if -1 then upward movement, 1 then downward\n    const dy = y2 - y1; // if -1 then leftward movement, 1 then rightward\n    return [dx, dy];\n  }\n\n  // Next attack coordinate based on predicted direction\n  getNextCoordinate([x, y], [dx, dy]) {\n    return [x + dx, y + dy];\n  }\n\n  // Reverse direction\n  reverseDirection([dx, dy]) {\n    return [-dx, -dy];\n  }\n\n  // Predict the ship's direction for computer's attack (2+ hits to the same ship)\n  findDirectionTarget(hitCoordinates) {\n    if (hitCoordinates.length < 2) return null;\n\n    // Fallback: sort coordinates if original order is ambiguous\n    // (ex: if the first hit is in the middle of the ship)\n    const sortedCoordinates = [...hitCoordinates].sort(([x1, y1], [x2, y2]) => {\n      return x1 !== x2 ? x1 - x2 : y1 - y2;\n    });\n\n    const attackDirection = (hits) => {\n      // First and last known hit\n      const initialHit = hits[0];\n      const lastHit = hits[hits.length - 1];\n\n      // Get direction based on the first two hits\n      let direction = this.getDirection(hits[0], hits[1]);\n\n      // Attack forward from last known hit\n      const [forwardX, forwardY] = this.getNextCoordinate(lastHit, direction);\n      if (this.isValidAttack(forwardX, forwardY)) return [forwardX, forwardY];\n\n      // Attack backward from initial hit if forward attack fails (miss cell or out of bounds)\n      direction = this.reverseDirection(direction);\n      const [backX, backY] = this.getNextCoordinate(initialHit, direction);\n      if (this.isValidAttack(backX, backY)) return [backX, backY];\n\n      return null; // Fallback if both directions fail\n    };\n\n    return (\n      attackDirection(hitCoordinates) || attackDirection(sortedCoordinates)\n    );\n  }\n\n  // Update target-tracking state after computer's attack\n  updateAttackState(ship, x, y) {\n    const isHit = ship && !ship.isSunk();\n\n    // Check if the targeted ship has sunk\n    const targetShipSunk = this.currTargetShip && this.currTargetShip.isSunk();\n\n    // Check if previously attacked ship should continue being attacked\n    const resumePrevAttack =\n      this.currTargetShip &&\n      !this.currTargetShip.isSunk() &&\n      this.currTargetShip.hitPositions.length >= 2;\n\n    if (isHit) {\n      this.lastHit = [x, y];\n      this.currTargetShip = ship; // Save the currently attacked ship\n\n      // If 2+ hits registered, predict the ship's orientation for the next attack\n      if (this.currTargetShip.hitPositions.length >= 2) {\n        this.nextTarget = this.findDirectionTarget(\n          this.currTargetShip.hitPositions,\n        );\n      }\n    } else if (resumePrevAttack) {\n      // Missed, keep attacking the known ship based on previous hits\n      this.nextTarget = this.findDirectionTarget(\n        this.currTargetShip.hitPositions,\n      );\n      this.lastHit = null;\n    }\n\n    if (targetShipSunk) {\n      // Reset all targeting state\n      this.resetTargetState();\n    }\n  }\n\n  // Reset all target data if no valid ship left to continue attacking (sunk or miss)\n  resetTargetState() {\n    this.lastHit = null;\n    this.nextTarget = null;\n    this.currTargetShip = null;\n  }\n}\n","export class Ship {\n  constructor(length) {\n    this.length = length;\n    this.hits = 0;\n    this.hitPositions = [];\n  }\n\n  hit(x, y) {\n    if (this.hits < this.length) {\n      this.hits += 1;\n      this.hitPositions.push([x, y]);\n    }\n  }\n\n  isSunk() {\n    return this.hits >= this.length;\n  }\n}\n","import { Ship } from \"./ships.js\";\nimport { setupPlayerShipDrop, shipRemoval } from \"./dom.js\";\n\nexport class PlaceShips {\n  constructor(player, requiredShips = 5) {\n    this.ships = [\n      new Ship(2),\n      new Ship(3),\n      new Ship(3),\n      new Ship(4),\n      new Ship(5),\n    ];\n    this.currentPlayer = player;\n    this.board = this.currentPlayer.gameboard.board;\n    this.boardSize = this.currentPlayer.gameboard.boardSize;\n    this.requiredShips = requiredShips;\n  }\n\n  placePlayerShips() {\n    // Listen for player's ship drop events\n    setupPlayerShipDrop((coordinates, shipLength, shipEl) => {\n      // If placement is valid, create and place a ship\n      if (this.validPlacement(coordinates)) {\n        const ship = new Ship(shipLength);\n        this.placeShipOnBoard(ship, coordinates);\n\n        // Remove ships from side panel only if the placement is valid\n        shipRemoval(shipEl);\n      }\n    }, this.validPlacement.bind(this)); // Pass validPlacement method for hover use in DOM\n  }\n\n  placeComputerShips() {\n    for (const ship of this.ships) {\n      let placed = false;\n\n      while (!placed) {\n        const isHorizontal = Math.random() < 0.5; // Randomly choose ship's orientation\n        const [x, y] = this.getStartingPoint(ship.length, isHorizontal); // Create starting point for each ship\n        const coordinates = this.getShipCoordinates(\n          x,\n          y,\n          ship.length,\n          isHorizontal,\n        );\n\n        // Place a ship if the placement is valid within the board\n        if (this.validPlacement(coordinates)) {\n          this.placeShipOnBoard(ship, coordinates);\n          placed = true;\n        }\n      }\n    }\n  }\n\n  // Place each ship with its coordinates on the gameboard\n  placeShipOnBoard(ship, coordinates) {\n    this.currentPlayer.gameboard.placeShip(ship, coordinates);\n  }\n\n  // Check if the cells are not occupied and not adjacent to ships\n  validPlacement(coordinates) {\n    return coordinates.every(([x, y]) => {\n      if (!this.inBounds(x, y) || this.board[x][y] === \"■\") return false; // Current cell is occupied, invalidate placement\n\n      const adjacentOffset = [\n        [-1, 0],\n        [1, 0],\n        [0, -1],\n        [0, 1],\n      ];\n\n      // Avoid adjacent ship placements (at least 1 cell gap in-between the ships, no diagonal gaps)\n      for (const [dx, dy] of adjacentOffset) {\n        // Adjacent cell coordinates\n        const sx = x + dx;\n        const sy = y + dy;\n\n        // If adjacent ship detected, invalidate placement\n        if (this.inBounds(sx, sy) && this.board[sx][sy] === \"■\") {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  // Check for ship coordinates to be within the board boundaries\n  inBounds(x, y) {\n    return x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize;\n  }\n\n  getShipCoordinates(x, y, shipSize, isHorizontal) {\n    const coords = [];\n\n    // If orientation is horizontal, increment y-coordinate\n    // If orientation is vertical, increment x-coordinate\n    for (let i = 0; i < shipSize; i++) {\n      coords.push(isHorizontal ? [x, y + i] : [x + i, y]);\n    }\n\n    return coords;\n  }\n\n  // For each ship generate random starting coordinate\n  getStartingPoint(shipSize, isHorizontal) {\n    const maxX = isHorizontal\n      ? this.boardSize // Horizontal: x can be anywhere\n      : this.boardSize - shipSize; // Vertical: x must have the room to fit the ship downward\n\n    const maxY = isHorizontal\n      ? this.boardSize - shipSize // Horizontal: y must have the room to fit the ship rightward\n      : this.boardSize; // Vertical: y can be anywhere\n\n    const shipX = Math.floor(Math.random() * maxX);\n    const shipY = Math.floor(Math.random() * maxY);\n\n    return [shipX, shipY];\n  }\n\n  // Check if all player ships haven been placed\n  allPlaced() {\n    const placedShips = new Set(\n      this.currentPlayer.gameboard.storeShip.values(),\n    );\n    return placedShips.size === this.requiredShips;\n  }\n}\n","import \"./styles/styles.css\";\n\nimport { computerPlayerBoardEl, setupUI } from \"./modules/dom.js\";\nimport { realPlayer, computerPlayer } from \"./modules/players.js\";\nimport { Game } from \"./modules/game.js\";\n\n// Player vs Computer\nexport const game = new Game(realPlayer, computerPlayer);\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  setupUI();\n  game.startSetup();\n\n  computerPlayerBoardEl.addEventListener(\"click\", (e) => {\n    const cell = e.target.closest(\".column\");\n    if (!cell) return;\n\n    game.handlePlayerMove(cell);\n  });\n});\n","import {\n  renderBoard,\n  switchBoard,\n  displayWinner,\n  getCoordinates,\n  updateCellState,\n  realPlayerBoardEl,\n  computerPlayerBoardEl,\n} from \"./dom.js\";\n\nimport { AIController } from \"./computerAI.js\";\nimport { PlaceShips } from \"./shipPlacement.js\";\n\nexport class Game {\n  constructor(realPlayer, computerPlayer) {\n    this.player1 = realPlayer;\n    this.player2 = computerPlayer;\n    this.currentPlayer = realPlayer;\n    this.opponent = computerPlayer;\n    this.turnInterval = null;\n    this.waitForPlayerInterval = null;\n    this.gameOver = false;\n\n    this.playerShipPlacer = new PlaceShips(this.player1);\n    this.computerShipPlacer = new PlaceShips(this.player2);\n\n    this.AI = new AIController(this.player1.gameboard); // Computer's AI\n  }\n\n  // Player must place ships first before the computer can\n  startSetup() {\n    // Player's ship placements (drag and drop)\n    this.playerShipPlacer.placePlayerShips();\n\n    // Wait for real player to place all their ships\n    this.waitForPlayerInterval = setInterval(() => {\n      if (this.playerShipPlacer.allPlaced()) {\n        clearInterval(this.waitForPlayerInterval);\n        switchBoard(this.player2, true); // Optional\n\n        // Computer done placing ships\n        setTimeout(() => {\n          // Computer's ship placements\n          this.computerShipPlacer.placeComputerShips();\n\n          // Rerender computer's board (with ships) and switch to real player for their first attack move\n          renderBoard(this.player2.gameboard, computerPlayerBoardEl);\n          switchBoard(this.player1);\n        }, 5000);\n      }\n    }, 1000);\n  }\n\n  // Reflect the player's move visually\n  processMoveResult(cell, boardElement) {\n    this.handleCellState(cell);\n    this.handleSunkShip(this.opponent, cell, boardElement);\n\n    // If there is a winner, end game\n    if (this.isWinner()) {\n      this.endGame();\n    }\n  }\n\n  handlePlayerMove(cell) {\n    const [x, y] = getCoordinates(cell);\n\n    this.opponent.gameboard.receiveAttack(x, y);\n\n    if (this.gameOver) return;\n\n    this.processMoveResult(cell, computerPlayerBoardEl);\n    this.switchTurn(); // Give turn to the computer\n\n    clearInterval(this.turnInterval); // Clear any existing intervals\n\n    // Set up an interval simulating computer's thinking\n    this.turnInterval = setInterval(() => this.handleComputerMove(), 2000);\n  }\n\n  handleComputerMove() {\n    const [x, y] = this.AI.computerAttacks(); // Get coordinate of the computer attack\n    const cell = realPlayerBoardEl.querySelector(\n      `[data-row=\"${x}\"][data-col=\"${y}\"]`,\n    );\n\n    if (this.gameOver) return;\n\n    this.processMoveResult(cell, realPlayerBoardEl);\n    this.switchTurn(); // Give turn back to the real player\n\n    // Reset interval completely after computer has attacked\n    clearInterval(this.turnInterval);\n    this.turnInterval = null;\n  }\n\n  switchTurn() {\n    if (!this.isWinner()) {\n      this.currentPlayer =\n        this.currentPlayer === this.player1 ? this.player2 : this.player1;\n\n      this.opponent =\n        this.currentPlayer === this.player1 ? this.player2 : this.player1;\n\n      switchBoard(this.currentPlayer);\n    }\n  }\n\n  // Mark the ship that has been sunk\n  handleSunkShip(targetPlayer, cell, boardElement) {\n    const [x, y] = getCoordinates(cell);\n    const targetShip = targetPlayer.gameboard.storeShip.get(`${x},${y}`);\n\n    if (!targetShip || !targetShip.isSunk()) return;\n\n    for (const [coordinates, ship] of targetPlayer.gameboard.storeShip) {\n      if (ship === targetShip && ship.isSunk()) {\n        // Get coordinates of each cell within the sunk ship\n        const [shipX, shipY] = coordinates.split(\",\").map((num) => Number(num));\n\n        // Set each cell of the sunk ship to value = \"sunk\"\n        targetPlayer.gameboard.board[shipX][shipY] = \"sunk\";\n\n        // Get each cell of the sunk ship\n        const cellShip = boardElement.querySelector(\n          `[data-row=\"${shipX}\"][data-col=\"${shipY}\"]`,\n        );\n\n        // Mark it visually as sunk based on \"sunk\" value\n        if (cellShip) this.handleCellState(cellShip);\n      }\n    }\n  }\n\n  // Retrieve the cell's state after player's move\n  handleCellState(cell) {\n    const [x, y] = getCoordinates(cell);\n    const value = this.opponent.gameboard.board[x][y];\n\n    updateCellState(value, cell);\n  }\n\n  // Check if there is a winner\n  isWinner() {\n    return this.opponent.gameboard.allSunk();\n  }\n\n  // End the game after the winner was found\n  endGame() {\n    this.gameOver = true;\n    clearInterval(this.turnInterval);\n    this.turnInterval = null;\n\n    displayWinner(this.currentPlayer);\n  }\n\n  // Full reset of the game\n  reset() {\n    this.gameOver = false;\n    this.currentPlayer = this.player1;\n    this.opponent = this.player2;\n\n    if (this.turnInterval) clearInterval(this.turnInterval);\n    if (this.waitForPlayerInterval) clearInterval(this.waitForPlayerInterval);\n\n    this.turnInterval = null;\n    this.waitForPlayerInterval = null;\n\n    this.player1.gameboard.resetBoard();\n    this.player2.gameboard.resetBoard();\n\n    this.playerShipPlacer = new PlaceShips(this.player1);\n    this.computerShipPlacer = new PlaceShips(this.player2);\n\n    this.AI = new AIController(this.player1.gameboard);\n  }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Gameboard","constructor","this","board","storeShip","Map","missedHits","trackAttacks","Set","boardSize","createBoard","i","Array","fill","placeShip","ship","coordinates","length","Error","forEach","x","y","set","receiveAttack","add","hit","push","allSunk","uniqueShips","values","isSunk","resetBoard","clear","Player","isComputer","gameboard","realPlayer","computerPlayer","realPlayerBoardEl","document","querySelector","computerPlayerBoardEl","sidePanel","restartBtn","winnerMsg","realPlayerStatus","computerPlayerStatus","realPlayerLabels","querySelectorAll","computerPlayerLabels","shipNames","shipRotationState","currentDraggedShipId","currentSegmentOffset","renderBoard","boardElement","innerHTML","row","createElement","classList","appendChild","j","cell","setAttribute","updateCellState","renderSidePanel","size","shipNum","shipWrapper","shipEl","id","span","textContent","segment","trackShipsSegment","addEventListener","e","target","closest","Number","getAttribute","dataTransfer","setData","toString","value","remove","switchBoard","player","placing","randomBtn","rotateBtn","toggle","label","getCoordinates","shipRemoval","style","maxWidth","opacity","setTimeout","getShipData","col","shipId","getData","getElementById","shipLength","offsetData","offset","computeShipPlacement","orientation","shipSize","isHorizontal","game","playerShipPlacer","getShipCoordinates","highlightShipSelection","el","handleShipRotation","selectedShip","shipName","selectedShipID","isRotated","transform","setupShipRotation","newRotateBtn","cloneNode","parentNode","replaceChild","setupRandomShipPlacement","ships","newRandomBtn","btn","allPlaced","placeComputerShips","cursor","handleRandomShipPlacement","handleRestart","display","reset","startSetup","AIController","oppGameboard","lastHit","nextTarget","currTargetShip","isValidAttack","has","computerAttacks","coordinate","targetShip","huntShip","keyCoordinate","updateAttackState","getRanCoordinate","min","max","Math","floor","random","mix","sort","dx","dy","sx","sy","getDirection","x1","y1","x2","y2","getNextCoordinate","reverseDirection","findDirectionTarget","hitCoordinates","sortedCoordinates","attackDirection","hits","initialHit","direction","forwardX","forwardY","backX","backY","isHit","targetShipSunk","resumePrevAttack","hitPositions","resetTargetState","Ship","PlaceShips","requiredShips","currentPlayer","placePlayerShips","callback","isValidPlacement","validPlacement","placeShipOnBoard","bind","preventDefault","isValid","dropEffect","hoverShipPlacementEffect","placed","getStartingPoint","every","inBounds","adjacentOffset","coords","maxX","maxY","player1","player2","opponent","turnInterval","waitForPlayerInterval","gameOver","computerShipPlacer","AI","setInterval","clearInterval","processMoveResult","handleCellState","handleSunkShip","isWinner","endGame","handlePlayerMove","switchTurn","handleComputerMove","targetPlayer","shipX","shipY","split","map","num","cellShip","winner","winnerBoard","loserBoard","winnerLabels","displayWinner"],"sourceRoot":""}